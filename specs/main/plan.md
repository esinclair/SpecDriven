````markdown
# Implementation Plan: User Management API System

**Branch**: `main` | **Date**: 2025-12-29 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/main/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command following the OpenAPI-first development workflow.

## Summary

This plan describes the implementation approach for a production-ready User Management REST API demonstrating OpenAPI-first development with Spring Boot 3.5.x and JDK 17. The system provides complete user lifecycle management (CRUD operations), role-based access control, JWT bearer token authentication, feature flag support, and comprehensive error handling with stable error codes and HTTP-based retry semantics. All functionality is gated by feature flags for safe incremental deployment.

## Technical Context

**Language/Version**: Java 17 (JDK 17 with Spring Boot 3.5.9)  
**Primary Dependencies**: Spring Boot 3.5.9, Spring Web, Spring Data JDBC, Spring Security, Spring Validation, JWT (jjwt 0.12.3), Flyway, OpenAPI Generator 7.14.0  
**Storage**: H2 in-memory database (SQL-compliant mode), Spring Data JDBC repositories  
**Testing**: JUnit 5, Spring Boot Test, Mockito, Spring Security Test  
**Target Platform**: JVM-based server (development: embedded Tomcat; production: containerized or standalone JAR)  
**Project Type**: Single Spring Boot web application (backend REST API)  
**Performance Goals**: â‰¤1s response time for 95% of synchronous operations (health check, login, CRUD operations, paginated list)  
**Constraints**: 
  - OpenAPI contract is source of truth; all API code generated
  - Error codes must be stable; retry semantics conveyed via HTTP status codes only (no `retryable` field)
  - No explicit API versioning (no `/v1`, headers, query params)
  - All changes must be backward compatible and additive
  - Feature flags control all user management endpoints via `FeatureFlag.usersApi`
  - Pagination required for all collection endpoints
**Scale/Scope**: Single-tenant monolithic application supporting hundreds of users with in-memory database for development and testing

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Initial Evaluation (Pre-Research)

âœ… **Tests are mandatory**: Plan includes comprehensive test strategy:
   - Unit tests for service layer logic (validation, business rules)
   - Integration tests using Spring Boot Test for full request-response flows
   - Negative tests for validation failures, authentication errors, not found scenarios, conflicts, and transient failures
   - Test coverage for feature flag enabled/disabled states

âœ… **Performance budget**: All synchronous operations designed to meet â‰¤1s response goal:
   - Health check: No database dependency, instant response
   - Login: Single database query + JWT generation (fast in-memory operations)
   - User CRUD: Single-row operations with indexed lookups by UUID primary key
   - List users: Paginated queries with LIMIT/OFFSET, maximum page size enforced (100 items)
   - No complex joins or aggregations in critical path
   - H2 in-memory database ensures sub-millisecond query times

âœ… **Paged results**: List users endpoint requires mandatory pagination parameters:
   - `page` (1-based, minimum 1) - REQUIRED query parameter
   - `pageSize` (minimum 1, maximum 100) - REQUIRED query parameter
   - Response includes pagination metadata: `totalCount`, `page`, `pageSize`, `totalPages`
   - OpenAPI contract explicitly defines pagination parameters and response structure

âœ… **Error contract**: Comprehensive error handling with stable codes:
   - All errors return `ErrorResponse` schema with `code` (string) and `message` (string) fields
   - Error codes: `VALIDATION_FAILED`, `RESOURCE_NOT_FOUND`, `CONFLICT`, `AUTHENTICATION_REQUIRED`, `AUTHENTICATION_FAILED`, `INTERNAL_ERROR`, `SERVICE_UNAVAILABLE`
   - HTTP status semantics:
     - 400 = validation errors (don't retry)
     - 401 = authentication errors (don't retry without valid credentials)
     - 404 = resource not found (don't retry)
     - 409 = conflict (don't retry without changing request)
     - 500 = internal error (may retry with backoff)
     - 503 = service unavailable (retry with exponential backoff; Retry-After header when available)
   - No `retryable` field in error responses

âœ… **Public API compatibility**: No versioning; only additive changes:
   - No `/v1` or version path segments in URLs
   - No version headers or query parameters
   - Existing operations: all inputs are explicitly defined; no new required inputs added
   - Future evolution: only optional inputs and optional output fields may be added
   - Breaking changes prohibited by constitution

âœ… **Feature flagging**: All user management endpoints gated:
   - Feature flag name: `FeatureFlag.usersApi` (Spring boolean property)
   - Default value: `false` (disabled until validated)
   - Flag controls: `/users/*`, `/login` endpoints
   - Health check `/ping` explicitly NOT gated (always available)
   - When disabled: endpoints return 404 with standard error body (no feature disclosure)
   - Tests cover both enabled and disabled states

âœ… **Build gate**: `./gradlew clean build` is the definition of done:
   - All tests must pass
   - OpenAPI generation must succeed
   - Application must start successfully
   - No compilation errors or warnings

### Post-Design Evaluation

âœ… **Tests are mandatory**: VERIFIED
   - Complete test strategy defined in plan
   - Unit tests for service layer, mappers, security components
   - Integration tests for full request-response flows
   - Test coverage includes happy paths + negative cases + edge cases
   - Performance tests validate â‰¤1s budget
   - All test types documented with naming conventions

âœ… **Performance budget**: VERIFIED
   - All synchronous operations designed for â‰¤1s response time
   - Health check: No DB dependency, instant response
   - Login: Single indexed query + JWT generation (fast)
   - CRUD: Single-row operations with UUID primary key lookups
   - List: Mandatory pagination (max 100 items per page)
   - Database indexes on all frequently queried columns
   - H2 in-memory ensures sub-millisecond query times

âœ… **Paged results**: VERIFIED
   - List users endpoint requires mandatory `page` and `pageSize` parameters
   - OpenAPI contract explicitly defines pagination parameters and response schema
   - Response includes complete pagination metadata: `totalCount`, `page`, `pageSize`, `totalPages`
   - Maximum page size enforced (100 items)
   - Database queries use LIMIT/OFFSET for performance

âœ… **Error contract**: VERIFIED
   - All errors return `ErrorResponse` with `code` and `message` fields
   - Error codes documented: `VALIDATION_FAILED`, `RESOURCE_NOT_FOUND`, `CONFLICT`, `AUTHENTICATION_REQUIRED`, `AUTHENTICATION_FAILED`, `INTERNAL_ERROR`, `SERVICE_UNAVAILABLE`
   - HTTP status codes mapped correctly (4xx = don't retry, 5xx = may retry)
   - `GlobalExceptionHandler` with `@ControllerAdvice` ensures consistency
   - `ErrorResponseFactory` generates stable error codes
   - No `retryable` field in any error response
   - Retry-After header documented for 503 responses

âœ… **Public API compatibility**: VERIFIED
   - No versioning in OpenAPI contract (no `/v1`, headers, query params)
   - All endpoints unversioned
   - Existing operations have well-defined required inputs
   - Future changes documented as additive-only (optional inputs, optional outputs)
   - Breaking changes explicitly prohibited by design

âœ… **Feature flagging**: VERIFIED
   - Feature flag defined: `FeatureFlag.usersApi` (Spring boolean property)
   - Default value: `false` (disabled)
   - All user management endpoints gated: `/users/*`, `/login`
   - Health check `/ping` explicitly NOT gated
   - Feature flag enforced via `FeatureFlagSecurityFilter`
   - When disabled: returns 404 with standard error (no feature disclosure)
   - Tests cover both enabled and disabled states
   - Configuration documented in application.yml

âœ… **Build gate**: VERIFIED
   - `./gradlew clean build` executes:
     - OpenAPI code generation
     - Compilation of all source code
     - All unit and integration tests
     - Package as executable JAR
   - Build must succeed for deployment
   - CI/CD pipeline can use this as quality gate

**Constitution Compliance**: âœ… 100% PASS - All constitutional principles satisfied

## Project Structure

### Documentation (this feature)

```text
specs/main/
â”œâ”€â”€ spec.md              # Feature specification (input)
â”œâ”€â”€ plan.md              # This file (implementation plan)
â”œâ”€â”€ research.md          # Phase 0 output (technology decisions)
â”œâ”€â”€ data-model.md        # Phase 1 output (entity designs)
â”œâ”€â”€ quickstart.md        # Phase 1 output (getting started guide)
â”œâ”€â”€ contracts/           # Phase 1 output (OpenAPI contract)
â”‚   â””â”€â”€ openapi.contract.yaml
â”œâ”€â”€ tasks.md             # Phase 2 output (implementation tasks)
â””â”€â”€ checklists/          # Quality gates and requirements tracking
    â””â”€â”€ requirements.md
```

### Source Code (repository root)

```text
SpecDriven/
â”œâ”€â”€ build.gradle                    # Gradle build with OpenAPI generation
â”œâ”€â”€ settings.gradle
â”œâ”€â”€ gradlew / gradlew.bat          # Gradle wrapper
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/com/example/specdriven/
â”‚   â”‚   â”‚   â”œâ”€â”€ SpecDrivenApplication.java           # Spring Boot main class
â”‚   â”‚   â”‚   â”œâ”€â”€ config/                              # Configuration classes
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SecurityConfig.java             # Spring Security config
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JwtConfig.java                  # JWT settings
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FeatureFlagConfig.java          # Feature flag properties
â”‚   â”‚   â”‚   â”œâ”€â”€ security/                            # Security components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JwtTokenProvider.java           # JWT generation/validation
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ JwtAuthenticationFilter.java    # Bearer token filter
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FeatureFlagSecurityFilter.java  # Feature flag enforcement
â”‚   â”‚   â”‚   â”œâ”€â”€ controller/                          # REST controllers (implement generated APIs)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PingController.java             # Health check
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LoginController.java            # Authentication
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UsersController.java            # User CRUD operations
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UserRolesController.java        # Role assignment
â”‚   â”‚   â”‚   â”œâ”€â”€ service/                             # Business logic
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserService.java                # User management logic
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LoginService.java               # Authentication logic
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RoleService.java                # Role management
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ FeatureFlagService.java         # Feature flag checks
â”‚   â”‚   â”‚   â”œâ”€â”€ repository/                          # Data access (Spring Data JDBC)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserRepository.java             # User persistence
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UserRoleRepository.java         # User-role mappings
â”‚   â”‚   â”‚   â”œâ”€â”€ domain/                              # Domain entities
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserEntity.java                 # User entity
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RoleEntity.java                 # Role entity
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PermissionEntity.java           # Permission entity
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UserRoleEntity.java             # Join entity
â”‚   â”‚   â”‚   â”œâ”€â”€ mapper/                              # API model â†” domain entity converters
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserMapper.java
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RoleMapper.java
â”‚   â”‚   â”‚   â””â”€â”€ exception/                           # Exception handling
â”‚   â”‚   â”‚       â”œâ”€â”€ GlobalExceptionHandler.java     # @ControllerAdvice for error responses
â”‚   â”‚   â”‚       â”œâ”€â”€ ValidationException.java
â”‚   â”‚   â”‚       â”œâ”€â”€ ResourceNotFoundException.java
â”‚   â”‚   â”‚       â”œâ”€â”€ ConflictException.java
â”‚   â”‚   â”‚       â””â”€â”€ ErrorResponseFactory.java       # Stable error code generation
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚       â”œâ”€â”€ application.yml                      # Spring Boot configuration
â”‚   â”‚       â”œâ”€â”€ openapi.yaml                         # OpenAPI contract (source of truth)
â”‚   â”‚       â””â”€â”€ db/migration/                        # Flyway SQL migrations
â”‚   â”‚           â”œâ”€â”€ V001__init_schema.sql           # Users table
â”‚   â”‚           â”œâ”€â”€ V002__roles_permissions.sql     # Roles and permissions
â”‚   â”‚           â””â”€â”€ V003__users_api.sql             # User-role mappings
â”‚   â”‚
â”‚   â”œâ”€â”€ main-gen/                                    # Generated code (do not edit manually)
â”‚   â”‚   â””â”€â”€ java/com/example/specdriven/
â”‚   â”‚       â””â”€â”€ api/
â”‚   â”‚           â”œâ”€â”€ LoginApi.java                    # Generated login API interface
â”‚   â”‚           â”œâ”€â”€ PingApi.java                     # Generated health check API
â”‚   â”‚           â”œâ”€â”€ UsersApi.java                    # Generated users API interface
â”‚   â”‚           â”œâ”€â”€ model/                           # Generated DTOs
â”‚   â”‚           â”‚   â”œâ”€â”€ User.java
â”‚   â”‚           â”‚   â”œâ”€â”€ CreateUserRequest.java
â”‚   â”‚           â”‚   â”œâ”€â”€ UpdateUserRequest.java
â”‚   â”‚           â”‚   â”œâ”€â”€ UserPage.java
â”‚   â”‚           â”‚   â”œâ”€â”€ LoginRequest.java
â”‚   â”‚           â”‚   â”œâ”€â”€ LoginResponse.java
â”‚   â”‚           â”‚   â”œâ”€â”€ ErrorResponse.java
â”‚   â”‚           â”‚   â”œâ”€â”€ PingResponse.java
â”‚   â”‚           â”‚   â”œâ”€â”€ Role.java
â”‚   â”‚           â”‚   â”œâ”€â”€ Permission.java
â”‚   â”‚           â”‚   â””â”€â”€ RoleName.java
â”‚   â”‚           â””â”€â”€ invoker/                         # Generated invoker (minimal)
â”‚   â”‚
â”‚   â””â”€â”€ test/
â”‚       â”œâ”€â”€ java/com/example/specdriven/
â”‚       â”‚   â”œâ”€â”€ integration/                         # Integration tests (full Spring context)
â”‚       â”‚   â”‚   â”œâ”€â”€ HealthCheckIntegrationTest.java
â”‚       â”‚   â”‚   â”œâ”€â”€ LoginIntegrationTest.java
â”‚       â”‚   â”‚   â”œâ”€â”€ UserCrudIntegrationTest.java
â”‚       â”‚   â”‚   â”œâ”€â”€ UserListIntegrationTest.java
â”‚       â”‚   â”‚   â”œâ”€â”€ RoleManagementIntegrationTest.java
â”‚       â”‚   â”‚   â””â”€â”€ FeatureFlagIntegrationTest.java
â”‚       â”‚   â”œâ”€â”€ service/                             # Unit tests for services
â”‚       â”‚   â”‚   â”œâ”€â”€ UserServiceTest.java
â”‚       â”‚   â”‚   â”œâ”€â”€ LoginServiceTest.java
â”‚       â”‚   â”‚   â””â”€â”€ RoleServiceTest.java
â”‚       â”‚   â”œâ”€â”€ security/                            # Security component tests
â”‚       â”‚   â”‚   â”œâ”€â”€ JwtTokenProviderTest.java
â”‚       â”‚   â”‚   â””â”€â”€ FeatureFlagSecurityFilterTest.java
â”‚       â”‚   â””â”€â”€ repository/                          # Repository tests
â”‚       â”‚       â”œâ”€â”€ UserRepositoryTest.java
â”‚       â”‚       â””â”€â”€ UserRoleRepositoryTest.java
â”‚       â””â”€â”€ resources/
â”‚           â””â”€â”€ application-test.yml                 # Test configuration
â”‚
â””â”€â”€ build/                                           # Build output (gitignored)
    â”œâ”€â”€ classes/
    â”œâ”€â”€ resources/
    â”œâ”€â”€ libs/
    â””â”€â”€ reports/
```

**Structure Decision**: Single Spring Boot project structure following standard Maven/Gradle conventions. All source code lives in `src/main/java` with handwritten implementations. Generated OpenAPI code lives in `src/main-gen/java` and is regenerated on every build. Tests organized by type (integration vs unit) for clarity. Feature follows standard Spring Boot project layout with clear separation of concerns (controllers, services, repositories, domain entities).

## Architecture & Design Patterns

### Layered Architecture

The application follows a classic layered architecture:

1. **API Layer** (Controllers)
   - Implement generated API interfaces from OpenAPI contract
   - Delegate to service layer for business logic
   - Handle request/response mapping via mappers
   - Do NOT contain business logic

2. **Service Layer**
   - Contains all business logic and validation
   - Orchestrates repository calls
   - Enforces business rules (e.g., email uniqueness, bootstrap mode)
   - Transactional boundaries defined here

3. **Repository Layer** (Data Access)
   - Spring Data JDBC repositories
   - Simple CRUD operations
   - Custom queries for filtering and pagination
   - No business logic

4. **Domain Layer** (Entities)
   - Plain Java objects representing database tables
   - Annotated with Spring Data JDBC annotations
   - Separate from API models (DTOs)

5. **Security Layer**
   - JWT token generation and validation
   - Spring Security filter chain
   - Feature flag enforcement filter
   - Authentication/authorization logic

### Key Design Patterns

#### 1. Contract-First (OpenAPI-First) Pattern

- **Problem**: API contracts can drift from implementation
- **Solution**: OpenAPI spec is the single source of truth; Java interfaces and models are generated
- **Implementation**:
  - Edit `src/main/resources/openapi.yaml` for any API changes
  - Run `./gradlew openApiGenerate` (automatic on build)
  - Implement generated interfaces in controllers
  - Never manually edit generated code in `src/main-gen/`

#### 2. Repository Pattern

- **Problem**: Need to abstract database access from business logic
- **Solution**: Spring Data JDBC repositories provide clean data access interface
- **Implementation**:
  - `UserRepository extends CrudRepository<UserEntity, UUID>`
  - `UserRoleRepository` for join table management
  - Custom queries using `@Query` annotation for filtering

#### 3. Mapper Pattern

- **Problem**: Generated API models (DTOs) differ from domain entities
- **Solution**: Dedicated mapper classes convert between API and domain models
- **Implementation**:
  - `UserMapper.toEntity(CreateUserRequest)` â†’ `UserEntity`
  - `UserMapper.toDto(UserEntity)` â†’ `User`
  - Password hashing happens in mapper during entity creation
  - Passwords never included in DTOs

#### 4. Global Exception Handling Pattern

- **Problem**: Need consistent error responses across all endpoints
- **Solution**: `@ControllerAdvice` with `@ExceptionHandler` methods
- **Implementation**:
  - `GlobalExceptionHandler` catches all exceptions
  - Maps exceptions to HTTP status codes
  - `ErrorResponseFactory` creates consistent `ErrorResponse` with stable codes
  - Never exposes internal details in error messages

#### 5. Feature Flag Pattern

- **Problem**: Need to enable/disable features without deployment
- **Solution**: Spring configuration properties + custom filter
- **Implementation**:
  - `@ConfigurationProperties("FeatureFlag")` class holds boolean flags
  - `FeatureFlagSecurityFilter` checks flag before allowing request
  - Returns 404 when feature disabled (no disclosure)
  - Health check endpoint explicitly bypasses feature flag check

#### 6. Bootstrap Mode Pattern

- **Problem**: Need to create first user without authentication (chicken-egg problem)
- **Solution**: Conditional security based on user count
- **Implementation**:
  - `POST /users` has dual security: `security: [{bearerAuth: []}, {}]` in OpenAPI
  - Custom security logic checks user count in database
  - If count = 0, allow without auth
  - If count > 0, require auth
  - All other endpoints always require auth

#### 7. Idempotent Operations Pattern

- **Problem**: Role assignment/removal should be safe to retry
- **Solution**: Operations that are naturally idempotent return 204 regardless
- **Implementation**:
  - Assign role: if already assigned, do nothing and return 204
  - Remove role: if not assigned, do nothing and return 204
  - No error thrown for duplicate operations

### Security Architecture

#### JWT Bearer Token Flow

1. Client calls `POST /login` with username/password (no auth required)
2. `LoginService` validates credentials against database
3. If valid, `JwtTokenProvider` generates signed JWT with claims:
   - `sub`: user ID
   - `exp`: expiration timestamp
   - `iat`: issued at timestamp
4. Token returned in `LoginResponse.token`
5. Client includes token in subsequent requests: `Authorization: Bearer <token>`
6. `JwtAuthenticationFilter` intercepts requests:
   - Extracts token from header
   - Validates signature and expiration
   - Sets Spring Security authentication context
7. Controllers access authentication via `@AuthenticationPrincipal`

#### Feature Flag Security Flow

1. Request arrives at server
2. `FeatureFlagSecurityFilter` checks if endpoint requires feature flag
3. If feature disabled and endpoint gated:
   - Return 404 with standard error (no feature disclosure)
   - Request never reaches controller
4. If feature enabled or endpoint not gated:
   - Pass to next filter in chain
5. Health check `/ping` explicitly bypasses all feature checks

### Database Schema

#### Users Table

```sql
CREATE TABLE users (
    id           UUID PRIMARY KEY DEFAULT random_uuid(),
    username     VARCHAR(100) NOT NULL,
    name         VARCHAR(255) NOT NULL,
    email_address VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email_address);
CREATE INDEX idx_users_username ON users(username);
```

#### Roles Table (Predefined)

```sql
CREATE TABLE roles (
    id          UUID PRIMARY KEY DEFAULT random_uuid(),
    role_name   VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(255)
);

-- Predefined roles
INSERT INTO roles (id, role_name, description) VALUES
    ('00000000-0000-0000-0000-000000000001', 'ADMIN', 'Full system access'),
    ('00000000-0000-0000-0000-000000000002', 'USER', 'Standard user access'),
    ('00000000-0000-0000-0000-000000000003', 'GUEST', 'Limited read-only access');
```

#### Permissions Table

```sql
CREATE TABLE permissions (
    id          UUID PRIMARY KEY DEFAULT random_uuid(),
    permission  VARCHAR(100) NOT NULL UNIQUE,
    description VARCHAR(255)
);

-- Predefined permissions
INSERT INTO permissions (permission, description) VALUES
    ('users:read', 'Read user data'),
    ('users:write', 'Create and update users'),
    ('users:delete', 'Delete users'),
    ('roles:assign', 'Assign roles to users');
```

#### Role-Permission Mapping

```sql
CREATE TABLE role_permissions (
    role_id      UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    permission_id UUID NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
    PRIMARY KEY (role_id, permission_id)
);

-- ADMIN has all permissions
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM roles r, permissions p WHERE r.role_name = 'ADMIN';

-- USER has read and write
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM roles r, permissions p 
WHERE r.role_name = 'USER' AND p.permission IN ('users:read', 'users:write');

-- GUEST has read only
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id FROM roles r, permissions p 
WHERE r.role_name = 'GUEST' AND p.permission = 'users:read';
```

#### User-Role Mapping

```sql
CREATE TABLE user_roles (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
    assigned_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, role_id)
);

CREATE INDEX idx_user_roles_user ON user_roles(user_id);
CREATE INDEX idx_user_roles_role ON user_roles(role_id);
```

### Error Code Catalog

All error responses follow this structure:

```json
{
  "code": "ERROR_CODE",
  "message": "Human-readable description"
}
```

#### Error Codes and HTTP Status Mapping

| Error Code | HTTP Status | Retry? | Description |
|------------|-------------|--------|-------------|
| `VALIDATION_FAILED` | 400 | No | Request validation failed (missing required fields, invalid formats) |
| `RESOURCE_NOT_FOUND` | 404 | No | Requested resource does not exist |
| `CONFLICT` | 409 | No | Resource conflict (e.g., duplicate email address) |
| `AUTHENTICATION_REQUIRED` | 401 | No* | No valid bearer token provided |
| `AUTHENTICATION_FAILED` | 401 | No* | Invalid credentials or token |
| `INTERNAL_ERROR` | 500 | Yes | Unexpected server error |
| `SERVICE_UNAVAILABLE` | 503 | Yes | Temporary unavailability (e.g., database connection failure) |

*Don't retry without fixing authentication (new token or credentials)

### Configuration Properties

#### application.yml

```yaml
# Feature Flags
FeatureFlag:
  usersApi: false  # Default: disabled until validated

# JWT Configuration
jwt:
  secret: ${JWT_SECRET:default-secret-change-in-production}
  expirationMs: 86400000  # 24 hours

# Database (H2)
spring:
  datasource:
    url: jdbc:h2:mem:specdriven;MODE=PostgreSQL;DB_CLOSE_DELAY=-1
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  h2:
    console:
      enabled: true
      path: /h2-console
  
# Flyway Migrations
  flyway:
    enabled: true
    locations: classpath:db/migration

# Server
server:
  port: 8080
  error:
    include-message: always
    include-binding-errors: never
    include-stacktrace: never
    include-exception: false
```

## Testing Strategy

### Test Pyramid

1. **Unit Tests** (Fast, Isolated)
   - Service layer: business logic, validation, error handling
   - Mapper layer: DTO â†” entity conversions
   - Security components: JWT generation/validation
   - Use Mockito to mock dependencies
   - No Spring context needed

2. **Integration Tests** (Full Stack)
   - Controller â†’ Service â†’ Repository â†’ Database
   - Uses `@SpringBootTest` with `@AutoConfigureMockMvc`
   - Test database (H2) reset between tests
   - Verify complete request-response flows
   - Test authentication and feature flags

### Test Coverage Requirements

#### Happy Path Tests (Every Endpoint)

- âœ… Health check returns 200
- âœ… Login with valid credentials returns token
- âœ… Create user with valid data returns 201
- âœ… Get user by ID returns 200 with user data
- âœ… Update user with valid data returns 200
- âœ… Delete user returns 204
- âœ… List users with pagination returns 200 with page
- âœ… Assign role returns 204
- âœ… Remove role returns 204

#### Negative Tests (Every Endpoint)

- âœ… Validation failures return 400 with VALIDATION_FAILED
- âœ… Not found returns 404 with RESOURCE_NOT_FOUND
- âœ… Authentication failures return 401 with AUTHENTICATION_FAILED
- âœ… Conflicts (duplicate email) return 409 with CONFLICT
- âœ… Feature flag disabled returns 404 (no disclosure)

#### Edge Cases

- âœ… Bootstrap mode: create first user without auth succeeds
- âœ… Post-bootstrap: create user without auth fails with 401
- âœ… Login with unknown username returns same error as wrong password
- âœ… Idempotent operations: assign/remove role multiple times
- âœ… Pagination boundaries: last page, empty results
- âœ… Password never returned in responses
- âœ… Role filtering in list users
- âœ… Concurrent updates to same user

#### Performance Tests

- âœ… Health check < 1s for 95% of requests
- âœ… Login < 1s for 95% of requests
- âœ… User CRUD operations < 1s for 95% of requests
- âœ… Paginated list < 1s for 95% of requests

### Test Naming Convention

```
[Method]_[Scenario]_[ExpectedResult]

Examples:
- login_ValidCredentials_ReturnsToken()
- createUser_DuplicateEmail_Returns409Conflict()
- getUserById_NotFound_Returns404()
- listUsers_FeatureFlagDisabled_Returns404()
```

### Authentication in Tests

Tests requiring authentication must follow this setup pattern:

1. **Check for existing test user**: Query the database to see if a test user already exists
2. **Create user if needed**: If no test user exists, create one (this also tests bootstrap mode)
3. **Login as test user**: Call the `/login` endpoint with test credentials to obtain an auth token
4. **Use auth token**: Include the JWT bearer token in the `Authorization` header for subsequent API calls
5. **Exercise endpoint under test**: Make the actual API call being tested with proper authentication

**Test User Credentials** (recommended standard across test suite):
```
Username: test@example.com
Password: TestPassword123!
Roles: ADMIN (for tests requiring elevated permissions)
```

**Example Integration Test Flow**:
```java
@Test
void getUserById_ValidId_Returns200() {
    // Step 1: Check if test user exists
    User existingUser = userRepository.findByEmail("test@example.com");
    
    // Step 2: Create if needed
    if (existingUser == null) {
        CreateUserRequest createRequest = new CreateUserRequest()
            .email("test@example.com")
            .password("TestPassword123!")
            .fullName("Test User");
        mockMvc.perform(post("/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(createRequest)))
            .andExpect(status().isCreated());
        existingUser = userRepository.findByEmail("test@example.com");
    }
    
    // Step 3: Login to get token
    LoginRequest loginRequest = new LoginRequest()
        .username("test@example.com")
        .password("TestPassword123!");
    String response = mockMvc.perform(post("/login")
        .contentType(MediaType.APPLICATION_JSON)
        .content(objectMapper.writeValueAsString(loginRequest)))
        .andExpect(status().isOk())
        .andReturn().getResponse().getContentAsString();
    String token = objectMapper.readValue(response, LoginResponse.class).getAccessToken();
    
    // Step 4 & 5: Use token to test the actual endpoint
    mockMvc.perform(get("/users/" + existingUser.getId())
        .header("Authorization", "Bearer " + token))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.email").value("test@example.com"));
}
```

**Helper Method Pattern** (recommended for cleaner tests):
```java
// Test base class or test utilities
protected String getAuthToken() {
    ensureTestUserExists();
    LoginRequest loginRequest = new LoginRequest()
        .username("test@example.com")
        .password("TestPassword123!");
    String response = mockMvc.perform(post("/login")
        .contentType(MediaType.APPLICATION_JSON)
        .content(objectMapper.writeValueAsString(loginRequest)))
        .andExpect(status().isOk())
        .andReturn().getResponse().getContentAsString();
    return objectMapper.readValue(response, LoginResponse.class).getAccessToken();
}

protected void ensureTestUserExists() {
    if (userRepository.findByEmail("test@example.com") == null) {
        CreateUserRequest createRequest = new CreateUserRequest()
            .email("test@example.com")
            .password("TestPassword123!")
            .fullName("Test User");
        mockMvc.perform(post("/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(createRequest)))
            .andExpect(status().isCreated());
    }
}
```

**Bootstrap Mode Consideration**: The first user creation in a test won't require authentication (bootstrap mode), but subsequent operations will. Tests should handle this gracefully by checking for existing users first.

**Test Isolation**: Each test class should use `@Transactional` or explicit database cleanup to ensure test independence, but may share a common test user setup via `@BeforeEach` or helper methods.

## Implementation Phases

### Phase 0: Research & Foundation âœ…

**Status**: Completed (see research.md)

**Key Decisions**:
- Spring Boot 3.5.9 with Spring Data JDBC for persistence
- H2 in-memory database for development
- JWT (jjwt library) for bearer tokens
- OpenAPI Generator for contract-first development
- Flyway for database migrations

### Phase 1: Design & Contracts âœ…

**Status**: Completed (see data-model.md, contracts/openapi.contract.yaml)

**Deliverables**:
- Complete OpenAPI contract with all endpoints, schemas, error responses
- Data model with entity definitions and relationships
- Quickstart guide for developers

### Phase 2: Core Implementation ğŸ”„

**Priority 1: Foundation & Health Check**

1. Spring Boot application structure
2. Security configuration (disabled for /ping)
3. Feature flag configuration and filter
4. Health check endpoint implementation
5. Global exception handler with error response factory
6. Tests for health check (with and without feature flag)

**Priority 2: Database & Migrations**

1. Flyway migration scripts (users, roles, permissions, mappings)
2. Domain entity classes with Spring Data JDBC annotations
3. Repository interfaces (UserRepository, UserRoleRepository)
4. Tests for repository layer

**Priority 3: Authentication**

1. JWT token provider (generation and validation)
2. JWT authentication filter
3. Login service (credential validation, token generation)
4. Login controller implementation
5. Bootstrap mode logic (user count check)
6. Tests for login (happy path, invalid credentials, bootstrap mode)

**Priority 4: User Management CRUD**

1. User service (create, read, update, delete with validation)
2. User mapper (API DTOs â†” domain entities)
3. Users controller implementation (delegates to service)
4. Password hashing in mapper
5. Email uniqueness enforcement
6. Tests for all CRUD operations (happy path + negative cases)

**Priority 5: User Listing & Pagination**

1. Paginated repository query methods
2. Filtering logic in service layer
3. List users controller implementation
4. Pagination metadata in response
5. Tests for pagination (multiple pages, filters, empty results)

**Priority 6: Role Management**

1. Role service (assign, remove with idempotency)
2. Role mapper
3. User roles controller implementation
4. Tests for role assignment/removal (happy path, idempotency, not found)

**Priority 7: Integration & End-to-End Testing**

1. Complete integration test suite
2. Feature flag enabled/disabled tests for all endpoints
3. Performance smoke tests
4. Error response consistency verification
5. Bootstrap mode integration test
6. Full user lifecycle test (create â†’ assign role â†’ update â†’ delete)

### Phase 3: Documentation & Validation â³

**Deliverables**:
- Updated README with API usage examples
- Quickstart guide for running locally
- API documentation (generated from OpenAPI)
- Test coverage report
- Performance test results

## Quality Gates

### Pre-Merge Checklist

- [ ] `./gradlew clean build` passes with all tests green
- [ ] OpenAPI contract regenerates without manual edits
- [ ] All endpoints have happy path tests
- [ ] All endpoints have negative tests (validation, not found, auth failures)
- [ ] Tests requiring authentication follow proper pattern (create user if needed â†’ login â†’ get token â†’ use token in request)
- [ ] Feature flag tests cover enabled and disabled states
- [ ] Error responses use stable codes and consistent structure
- [ ] No `retryable` field in any error response
- [ ] Bootstrap mode logic tested (zero users vs one or more users)
- [ ] Performance tests show â‰¤1s for 95% of operations
- [ ] Pagination tested with multiple pages and empty results
- [ ] Role operations tested for idempotency
- [ ] Passwords never returned in responses
- [ ] Login errors don't enumerate usernames
- [ ] No breaking changes to API contract

### Definition of Done

A feature is complete when:

1. **Functionality**
   - All acceptance scenarios from spec pass
   - All negative scenarios handled correctly
   - Feature flag controls access as specified

2. **Testing**
   - Unit tests: service logic, mappers, security components
   - Integration tests: full request-response flows
   - Test coverage: happy paths + negative cases + edge cases
   - Performance: â‰¤1s budget validated

3. **Code Quality**
   - No manual edits to generated code
   - Follows Spring Boot conventions
   - Exception handling via GlobalExceptionHandler
   - Clean separation of concerns (controller â†’ service â†’ repository)

4. **Documentation**
   - OpenAPI contract updated (if API changed)
   - Code comments for complex logic
   - README updated with usage examples

5. **Build**
   - `./gradlew clean build` succeeds
   - Application starts without errors
   - Feature flag defaults documented in application.yml

## Complexity Tracking

> **Note**: No constitution violations detected. This section is included for completeness but is empty as the plan adheres to all constitutional principles.

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| *(none)* | *(n/a)* | *(n/a)* |

## Risk Mitigation

### Risk: Generated code conflicts with handwritten code

**Mitigation**: 
- Generated code lives in separate source root (`src/main-gen/`)
- Controllers implement generated interfaces without modifying them
- Build process regenerates on every compile

### Risk: Feature flag disabled by default prevents testing

**Mitigation**:
- Integration tests override feature flag to `true` in test configuration
- Separate tests verify flag disabled behavior (404 responses)
- Documentation clearly states flag must be enabled for production

### Risk: Bootstrap mode security bypass

**Mitigation**:
- Bootstrap mode only active when user count = 0 (atomic check)
- After first user created, all operations require auth
- Integration tests verify bootstrap mode ends after first user
- No way to re-enter bootstrap mode without database reset

### Risk: JWT secret in configuration

**Mitigation**:
- Default secret only for development
- Production deployment must override via environment variable: `JWT_SECRET`
- Documentation warns against using default secret
- Secret should be rotated regularly in production

### Risk: H2 in-memory database data loss

**Mitigation**:
- H2 is for development/testing only (documented)
- Production should use persistent database (PostgreSQL, MySQL, etc.)
- Database type configurable via Spring properties
- Flyway migrations work across database types

### Risk: Performance degradation with large datasets

**Mitigation**:
- Mandatory pagination prevents unbounded queries
- Maximum page size enforced (100 items)
- Database indexes on frequently queried columns (email, username, user ID)
- Performance tests validate â‰¤1s budget with representative data sizes

## Next Steps

1. âœ… **Phase 0 Complete**: Research decisions documented in research.md
2. âœ… **Phase 1 Complete**: Data model and OpenAPI contract defined
   - âœ… OpenAPI contract created: `specs/main/contracts/openapi.contract.yaml`
   - âœ… OpenAPI contract copied to source: `src/main/resources/openapi.yaml`
   - âœ… Configuration file created: `src/main/resources/application.yml`
   - âœ… Agent context updated: `.github/agents/copilot-instructions.md`
3. ğŸ“‹ **Phase 2 Ready**: Implementation tasks to be defined
   - **Action Required**: Run `/speckit.tasks` to generate detailed implementation tasks from this plan
   - **Implementation Status**: Code generation succeeds; application implementation pending
   - **Build Status**: OpenAPI code generation âœ… | Application code â³
4. â³ **Phase 3 Pending**: Validation and documentation after implementation complete

**Current State**:
- âœ… Planning complete with architecture, design patterns, and implementation approach
- âœ… OpenAPI contract validated and generating Java interfaces/models
- âœ… Configuration files in place (application.yml, openapi.yaml)
- â³ Application implementation pending (controllers, services, repositories, security)
- â³ Tests pending (unit and integration test suites)

**To proceed with implementation**:
1. Run `/speckit.tasks` to generate detailed task breakdown
2. Implement each component following the architecture defined in this plan
3. Run `./gradlew clean build` frequently to verify build and tests
4. Deploy when all tests pass

---

**Plan Version**: 1.0  
**Last Updated**: 2025-12-29  
**Status**: âœ… Planning Complete - Ready for Implementation Tasks
````

